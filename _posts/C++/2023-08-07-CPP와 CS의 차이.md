---
title: C++과 C#의 차이
date: 2023-08-07 20:59:27 +0900
categories:
  - 풀스택 개발
  - C++
tags:
  - c
  - clr
  - il
  - jit
  - 가비지 컬렉터
  - 값 타입
  - 구조체
  - 참조 타입
  - 컴파일
---
C++과 C#은 둘 다 객체지향 언어로 게임 개발(Unreal, Unity)에 사용되는 언어입니다. 두 언어 모두 각각의 특징이 있고, 장단점이 있는 언어입니다.

C++는 기계어 코드로 직접 컴파일되기 때문에, 빠른 실행이 가능하고 개발자가 직접 메모리를 관리할 수 있기 때문에 메모리 관리 측면에서도 유연하고 효율적입니다.

반면, C#은 .NET 가상 머신 환경 위에서 실행하기 위해 JIT 컴파일을 사용하고 GC를 이용해 메모리 관리를 자동화합니다.

# 컴파일 언어

C++과 C# 모두 컴파일 언어입니다. 다만, 컴파일 방식과 결과가 조금 다릅니다.

<span class="keyword">**C++**</span>은 <span class="font_highlight">**컴파일 후 실행 가능한 기계어 코드**로 직접 컴파일 합니다</span>. 이 과정은 프로그램 실행 전에 완료되며, 이로 인해 C++로 작성한 코드는 운영체제가 바로 실행할 수 있게 컴파일 됩니다.

반면에,<span class="keyword">**C#**</span>은 운영체제 위의 .NET이라는 가상 머신 환경에서 실행되기 때문에, C#은 컴파일 언어이지만<span class="font_highlight">JIT(Just-In-Time) 컴파일</span>을 사용하는 언어입니다.

따라서, **C#**으로 작성된 소스 코드는 **.NET**에 적합한 <span class="font_highlight">**중간 언어(IL, Intermediate Language)**로 컴파일되고, 실행 시점에 **CLR(Common Language Runtime)**에 의해 기계어 코드로 <span class="important">**JIT 컴파일**</span></span>됩니다.

*(JIT 컴파일에 대해서는 [C#의 JIT 컴파일이란?](/posts/CS%EC%9D%98-JIT-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%9D%B4%EB%9E%80/){:target="_blank"} 포스트에 정리해뒀습니다.)*

정리하자면, 

<span class="keyword">C++</span>은 바로 실행 가능한 기계어 코드로 변환하기 때문에 빠르지만, 

<span class="keyword">C#</span>은 .NET이라는 가상 머신 환경에서 실행되기 때문에 IL로 컴파일 되고, 그로 인해 플랫폼 독립적인 코드를 작성할 수 있습니다.

따라서 C++은 컴파일 시간이 C#에 비해 길고 JIT 컴파일이 되는 유니티에 반해 언리얼은 컴파일로 핫 리로딩하는 시간이 필요합니다.

# 동적 할당과 메모리 관리

**<span class="keyword">C++</span>에서는 개발자가 직접 메모리를 할당하고 해제하는 것이 가능**합니다. `new` 와 `delete` 와 같은 키워드로 동적 메모리 할당과 해제를 수행하며, 이를 통해 개발자가 직접 필요 없는 메모리만 빠르게 처리할 수 있습니다.

즉, C++은 개발자가 직접 메모리를 관리하여 **빠르고 효율적인 메모리 관리**가 가능합니다. 

다만, 사용되지 않는 메모리를 그냥 두었을 경우 **메모리 누수**와 같은 문제가 발생할 수 있으며, 이를 관리하는 책임은 개발자에게 있습니다.

물론, C++11부터 스마트 포인터라는 개념이 등장했고, Unreal에서는 자체적인 가비지 컬렉터(GC)가 존재합니다.

반면, **<span class="keyword">C#</span>은 가비지 컬렉터(GC)를 통해 메모리 관리를 자동으로 수행**합니다.

GC는 더 이상 필요하지 않은 객체를 자동으로 해제하여 메모리 누수를 방지하고, 개발자의 부담을 줄여줍니다. 하지만, GC의 작동 시점과 메커니즘은 알기 어려워 일부 성능 문제가 발생할 수 있습니다.

# 자료형 (값 타입/참조 타입)

위의 메모리 관리와 관련해서 C++과 C#의 자료형에도 차이가 발생합니다.

C++에서는 값 타입과 참조 타입의 구분이 명확하지 않으며, 주로 동적 할당 여부에 따라 구분됩니다.

C++에서 정적으로 할당 가능한 모든 형태의 데이터 타입을 값 타입이라고 할 수 있습니다. `int`, `char`, `struct`, `class` 모두 해당합니다. 또한, 이를 동적 할당 할 수도 있는데, 이렇게 동적 할당된 타입은 참조 타입이라고 할 수 있습니다.

C#에서는 값 타입과 참조 타입이 구분되어 존재합니다.

C#에서는 `기본 자료형`과 `struct`는 **<span class="important">값 타입</span>**이며, `class`와 `interface`는 **<span class="important">참조 타입</span>**입니다.

> **구조체의 차이**
> 
> 1. C++의 struct는 class 와 거의 차이가 없습니다. 기본 접근 제한자가 구조체는 public 이고, class 는 private 라는 점 뿐입니다.
> 2. 반면 C#의 구조체는 class와 많이 다릅니다.
>     - C#은 포인터를 지원하지 않기 때문에 struct는 **값 타입**, class 는 **참조 타입**으로 명확하게 구분합니다.
>     - struct는 상속할 수 없지만 **interface를 구현**할 수 있습니다.
>     - struct는 기본 생성자를 가질 수 없습니다. (매개변수를 가진 생성자는 가질 수 있습니다.) 또한 소멸자를 가질 수 없습니다.
{: .prompt-tip }

## 기타 차이점

- <span class="important">C++</span>은 다중 상속을 지원하지만, <span class="important">C#</span>에서는 인터페이스를 통한 다중 상속만 가능합니다.
- <span class="important">C++</span>에선 int 타입으로도 bool 타입과 대신 참/거짓 판단이 가능했지만, <span class="important">C#</span>은 bool 타입으로만 가능합니다.
- <span class="important">C#</span>은 이벤트와 델리게이트와 같은 고급 언어 기능을 기본으로 지원합니다. 반면, <span class="important">C++</span>는 이러한 기능을 직접 구현해야 합니다. (Unreal C++에는 델리게이트와 같은 기능이 자체적으로 지원됩니다.)
- C++에서는 **`switch`**문의 **`case`** 레이블에 문자열을 사용할 수 없었지만, C#에서는 가능합니다. 또한, C++에서는 **`case`** 문을 작성한 뒤 **`break`**문으로 빠져나오지 않으면 바로 다음 레이블로 이동하지만, C#에서는 다음 레이블로 이동하지 않습니다.