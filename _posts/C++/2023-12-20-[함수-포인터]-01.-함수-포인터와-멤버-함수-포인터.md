---
title: "[함수 포인터] 01. 함수 포인터와 멤버 함수 포인터"
date: 2023-12-20 20:53:51 +0900
categories:
  - C++
  - 풀스택 개발
tags:
  - c
  - 객체 지향
  - 델리게이트
  - 유연성
  - 포인터
  - 함수
  - 확장성
  - 디커플링
math: false
type: C++
keywords:
  - 함수 포인터
  - 멤버 함수 포인터
---

프로그램에서 정의된 함수는 프로그램 실행 시 메모리에 로드됩니다.

이때, **함수의 이름**은 실제로 해당 함수의 기계어 코드가 저장된 <span class="font_highlight">**메모리 주소를 참조하는 식별자**</span>로 사용됩니다.

이 주소는 함수 코드의 시작 지점을 나타내며, 이를 통해 함수를 간접적으로 호출할 수 있습니다.

**함수 포인터**는 이러한 **함수의 시작 주소를 저장하는 변수**입니다. 즉, 함수 포인터는 <span class="font_highlight">특정 함수를 가리키는 포인터</span>로, 해당 함수의 메모리 주소를 담고 있습니다.

이를 활용하여 프로그램 내에서 다양한 함수를 동적으로 호출하거나, 콜백과 같은 고급 프로그래밍 기법을 구현할 수 있습니다.

---

# 함수 포인터의 기본 구조

함수 포인터의 기본 형태는 다음과 같습니다.

**반환_타입 (*포인터_이름)(매개변수_타입);**
{: .text-center}

이때, **반환 타입**과 **매개 변수 타입**은 저장할 함수의 시그니처와 일치해야 합니다.

예를 들어, 다음과 같은 함수를 함수 포인터로 만든다면, 반환 타입과 매개 변수 타입을 일치시켜 다음과 같이 만들 수 있습니다.

```cpp
int add(int a, int b);
int main()
{
	int (*funcPtr)(int, int) = add;
	funcPtr(1, 2);
}
```

## 함수 포인터의 초기화

위의 예제 코드에서 잠깐 나왔지만, 함수 포인터에 함수를 넣어 초기화 하는 방법은, **함수 포인터**에 **해당 <span class="font_highlight">함수의 식별자</span>로 초기화** 해줍니다.


> 여기에서 해당 함수의 식별자란, 함수의 이름을 말합니다.
> 
> **함수의 이름**은 컴파일 시 해당 함수의 기계어 코드가 저장된 **메모리 주소를 참조하는 식별자로 변환**됩니다.
> 
{: .prompt-tip}

또한, C++에서는 함수 이름을 함수 포인터에 할당할 때, 함수의 주소를 **암묵적으로 변환**하여 저장합니다. 따라서 주소 연산자 `&`를 사용하지 않아도 됩니다.

```cpp
funcPtr = add; // 암시적 주소 저장
funcPtr = &add; // 명시적 주소 저장

funcPtr(1, 2); // 함수 사용
(*funcPtr)(1, 2); // 명시적 역참조를 사용하여 add 함수를 호출합니다. 이는 add(1, 2)를 호출하는 것과 동일합니다.
```

---

# 객체(Class)에서의 함수 포인터

C++에서 클래스(객체)와 관련된 함수 포인터를 사용하는 방법은 일반 함수 포인터와는 다소 차이가 있습니다.

클래스의 멤버 함수는 객체의 상태에 접근할 수 있어야 하기 때문에, 멤버 함수 포인터를 사용할 때는 **객체의 컨텍스트**도 함께 고려해야 합니다.

## 클래스 멤버 함수 포인터

클래스의 멤버 함수 포인터는 클래스 타입과 함수 시그니처를 모두 포함해야 합니다.

멤버 함수 포인터의 선언은 다음과 같은 형태를 가집니다.

반환_타입 (**클래스명::*함수_식별자**)(매개변수_타입);
{: .text-center}

물론, 이렇게 한다고 해서 끝나는게 아닙니다.

이를 호출하기 위해서는 위에서도 말했듯이 클래스의 멤버 함수는 **<span class="font_highlight">객체에 접근할 수 있어야 하기 때문</span>에 인스턴스를 함께 제공**해야 합니다.

```cpp
#include <iostream>

class MyClass
{
public:
	void Add(int a, int b)
	{
		std::cout << "MyClass Add: " << (a + b) << std::endl;
	}
};

int main()
{
	void (MyClass::*FuncPtr)(int, int) = &MyClass::Add;

	MyClass myClass1; // 객체의 인스턴스가 있어야 한다.
	(myClass1.*FuncPtr)(1, 2); // myClass1의 컨텍스트에서 Add에 접근.

	MyClass myClass2;
	(myClass2.*FuncPtr)(1, 2); // myClass2의 컨텍스트에서 Add에 접근.
}
```

이는, **`this` 포인터**와 관련이 있기도 한데, 우선은 우리가 평소에 멤버 함수를 호출하듯이 호출한다고 생각하고 사용하는 것이 이해하기 빠를 것 같습니다.
this 포인터와 관련된 내용은 함수 [호출 규약의 thiscall](/posts/%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C-%EA%B7%9C%EC%95%BD-(cdecl,-stdcall,-thiscall,-fastcall)/#__thiscall){: target="_blank"}과 연관되어 있기에 한 번 일어보는 것도 추천드립니다.

```cpp
MyClass myClass3;
myClass3.Add(1, 2); // 일반적으로 멤버 함수를 호출하는 방법
```

---

# 참고

[함수 호출 규약 (cdecl, stdcall, thiscall, fastcall)](/posts/%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C-%EA%B7%9C%EC%95%BD-(cdecl,-stdcall,-thiscall,-fastcall)/)

[[함수 포인터] 02. 콜백 함수와 델리게이트](/posts/%ED%95%A8%EC%88%98-%ED%8F%AC%EC%9D%B8%ED%84%B0-02.-%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98%EC%99%80-%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8/){: }

[[함수 포인터] 03. 일급 객체와 고차 함수](/posts/%ED%95%A8%EC%88%98-%ED%8F%AC%EC%9D%B8%ED%84%B0-03.-%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4%EC%99%80-%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98/){: }

[[함수 포인터] 04. 함수 포인터를 보기 좋게 만들기](/posts/%ED%95%A8%EC%88%98-%ED%8F%AC%EC%9D%B8%ED%84%B0-04.-%ED%95%A8%EC%88%98-%ED%8F%AC%EC%9D%B8%ED%84%B0%EB%A5%BC-%EB%B3%B4%EA%B8%B0-%EC%A2%8B%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0/)